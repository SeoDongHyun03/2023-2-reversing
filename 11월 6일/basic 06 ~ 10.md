# 6번
우선 06.exe를 실행하면 다음과 같은 창이 나타납니다.(올바른 문자열을 적으라는 의미인 것 같습니다.)  
<img src="./basic 06/6-1.jpg">  
일단 아무거나 입력하고 버튼을 누르니까 다음과 같은 잘못됬다는 창이 나왔습니다.  
<img src="./basic 06/6-2.jpg">  
일단 이 문제를 풀기 전에 생각했던 것이 하나 있다. 우리는 이러한 비밀번호를 찾는 문제는 이미 풀어봤다.  
바로 **basic 03, 04**에서 풀어본 형식이다. 따라서 이번에도 현재 코드에 있는 문자열을 검색했는데 다음과 같은 문자열들이 나왔다.  
<img src="./basic 06/6-3.jpg">  
보면 일단 정체불명의 문자열인 **AD46DFS547**가 있고, 그 밑으로 **Good Job** 이랑 밑에 **wrong serial**이라는 문자열이 나왔다.  
wrong serial은 우리가 아까 잘못된 값을 입력했을 때 나왔던 창의 메세지이다. 따라서 여기에 관련된 코드들이 있을 것이라고 추측할 수 있다.  
그래서 문자열이 있는 곳으로 이동했더니 다음과 같은 코드들이 나왔다.  
<img src="./basic 06/6-4.jpg">  
위의 **test**구문을 통하여 **ZF**값이 바뀌고, 이에 따라서 값이 올바른지, 틀렸는지 확인하는 코드이다.  
그래서 위의 비밀번호로 추정되는 문자열을 입력했고, 그 결과 다음과 같이 올바른 비밀번호라는 메세지 창이 나왔다.  
<img src="./basic 06/6-5.jpg">  
우선 비밀번호는 **AD46DFS547**인 것을 알 수 있다.  
그런데 문제에서는 **OEP + Serial**을 적으라고 했다. OEP를 처음 들어서 검색해봤다.(https://wisetrue.tistory.com/72 참고)  
결론적으로 OEP는 **실제 시작 지점**을 의미한다고 한다. 아직은 감이 오지 않아서 더 검색했다.(https://wonlf.tistory.com/entry/codeengn-basic-L06-%ED%92%80%EC%9D%B4 참고)  
알고보니 지금 풀고있는 문제의 파일은 **UPX 패킹**이 되어있는 상태였다.  
물론 프로그램을 사용하여 언패킹할 수 있지만, 참고한 사이트에서 한 것 처럼 **pushad, popad**를 이용해 찾으려고 한다.  
(https://movefast.tistory.com/191 참고)  
우선 **pushad**는 쉽게 말하면 스택에 값들을 저장(백업)하는 용도로 사용하는 명령어이다.  그리고 **popad**는 스택에서 저장(백업)했던 값들을 가져오는 명령어이다.  
패킹을 한 파일의 대부분은 pushad를 통해 값을 저장했다가 프로그램을 시작하기 직전에 popad를 통해 값을 가져오고 프로그램을 시작한다.  
따라서 우리는 popad를 찾으면 oep를 찾을 수 있다.  
위에서 참고한 사이트에서 한 것처럼 pushad를 하고나서 스택에 breakpoint를 걸면, 나중에 popad를 실행할 때 멈출 것이다.(값을 가져가기 때문에 breakpoint에 의해 멈춘다)  
그래서 breakpoint를 걸고나서 실행한 결과, 다음 위치로 이동했다.  
<img src="./basic 06/6-6.jpg">  
여기서 우리가 집중해서 봐야하는 명령어는 **jmp**이다.  
왜냐하면 jmp를 통해 이동해야 프로그램을 시작하기 때문이다. 즉, jmp에 있는 주소가 우리가 찾고자 하는 프로그램의 시작 주소이다.  
따라서 oep는 **00401360**이다.  
따라서 정답은 **00401360AD46DFS547** 이다.  

# 7번  
07.exe를 실행하면 다음과 같은 창이 나타납니다.  
<img src="./basic 07/7-1.jpg">  
역시 아무거나 입력하면 다음과 같은 창이 나옵니다.  
<img src="./basic 07/7-2.jpg">  
디버깅을 해보니, 바로 밑에 시리얼처럼 보이는 것들이 보였습니다.
<img src="./basic 07/7-3.jpg">  
그리고 시리얼이 나와있는대로 입력했는데 틀렸다고 나왔습니다. 그래서 시리얼로 추정되는 문자열이 있는 명령어에 breakpoint를 걸고 디버깅을 했습니다.  
<img src="./basic 07/7-4.jpg">  
그런데 갑자기 **로컬 디스크**를 **GetVolumnInformationA** 라는 함수의 결과로 가져왔습니다.  
<img src="./basic 07/7-5.jpg">  
그래서 문제를 보았는데, **컴퓨터 C 드라이브의 이름이 CodeEngn 일경우 시리얼이 생성될때 CodeEngn은 'ß어떤것'으로 변경되는가** 라는 문제였습니다.  
이걸 보고, 저 **로컬 디스크**라는 것이 시리얼에 영향을 준다는 것을 알았습니다. 그래서 로컬 디스크가 있는 메모리 주소로 가서 값을 **CodeEngn**으로 바꾸었습니다.  
<img src="./basic 07/7-6.jpg">  
바꾼 후, 코드를 실행하니까 다음과 같은 시리얼처럼 생긴 문자열이 나왔습니다.  
<img src="./basic 07/7-7.jpg">  
그래서 입력을 했고, 결과는 성공적이었습니다.  
<img src="./basic 07/7-8.jpg">  
그런데 문제는 **CodeEngn은 'ß어떤것'으로 변경되는가**입니다. 그래서 시리얼을 자세히 봤는데, **L2C-5781EqfgEngn4562-ABEX**였습니다. 중간에 Engn이 있는 것으로 보면 CodeEngn이 들어간 것 같은데, CodeEngn이 **EqfgEngn**으로 바뀌어있었습니다.  
따라서 정답은 **EqfgEngn**입니다.  

# 8번  
이 프로그램을 실행하면 다음과 같은 계산기 프로그램이 나옵니다.  
<img src="./basic 08/8-1.jpg">  
우선 이 문제는 **OEP**를 구하는 문제이기 때문에 basic 07과 똑같은 문제입니다.  
근데 저는 basic 07은 직접 breakpoint를 걸어서 풀었는데, 이번에는 **프로그램**을 사용하여 풀어보겠습니다.(https://koharinn.tistory.com/487 https://blueochild.tistory.com/entry/UPX-%EC%96%B8%ED%8C%A8%ED%82%B9-%ED%95%98%EB%8A%94%EB%B2%95 참고)  
먼저 **PEiD**를 사용하여 어떤 방식으로 패킹돼있는지 확인했습니다.  
<img src="./basic 08/8-2.jpg">  
**UPX**로 패킹돼있습니다.  
그래서 UPX를 언패킹했습니다.  
<img src="./basic 08/8-3.jpg">  
그리고 x64dbg를 사용하여 프로그램을 실행하면, 다음과 같이 OEP를 쉽게 구할 수 있습니다.  
<img src="./basic 08/8-4.jpg">  
따라서 OEP는 **01012475** 입니다.  

# 9번

# 10번 

# 6번
우선 06.exe를 실행하면 다음과 같은 창이 나타납니다.(올바른 문자열을 적으라는 의미인 것 같습니다.)  
<img src="./basic 06/6-1.jpg">  
일단 아무거나 입력하고 버튼을 누르니까 다음과 같은 잘못됬다는 창이 나왔습니다.  
<img src="./basic 06/6-2.jpg">  
일단 이 문제를 풀기 전에 생각했던 것이 하나 있다. 우리는 이러한 비밀번호를 찾는 문제는 이미 풀어봤다.  
바로 **basic 03, 04**에서 풀어본 형식이다. 따라서 이번에도 현재 코드에 있는 문자열을 검색했는데 다음과 같은 문자열들이 나왔다.  
<img src="./basic 06/6-3.jpg">  
보면 일단 정체불명의 문자열인 **AD46DFS547**가 있고, 그 밑으로 **Good Job** 이랑 밑에 **wrong serial**이라는 문자열이 나왔다.  
wrong serial은 우리가 아까 잘못된 값을 입력했을 때 나왔던 창의 메세지이다. 따라서 여기에 관련된 코드들이 있을 것이라고 추측할 수 있다.  
그래서 문자열이 있는 곳으로 이동했더니 다음과 같은 코드들이 나왔다.  
<img src="./basic 06/6-4.jpg">  
위의 **test**구문을 통하여 **ZF**값이 바뀌고, 이에 따라서 값이 올바른지, 틀렸는지 확인하는 코드이다.  
그래서 위의 비밀번호로 추정되는 문자열을 입력했고, 그 결과 다음과 같이 올바른 비밀번호라는 메세지 창이 나왔다.  
<img src="./basic 06/6-5.jpg">  
우선 비밀번호는 **AD46DFS547**인 것을 알 수 있다.  
그런데 문제에서는 **OEP + Serial**을 적으라고 했다. OEP를 처음 들어서 검색해봤다.(https://wisetrue.tistory.com/72 참고)  
결론적으로 OEP는 **실제 시작 지점**을 의미한다고 한다. 아직은 감이 오지 않아서 더 검색했다.(https://wonlf.tistory.com/entry/codeengn-basic-L06-%ED%92%80%EC%9D%B4 참고)  
알고보니 지금 풀고있는 문제의 파일은 **UPX 패킹**이 되어있는 상태였다.  
물론 프로그램을 사용하여 언패킹할 수 있지만, 참고한 사이트에서 한 것 처럼 **pushad, popad**를 이용해 찾으려고 한다.  
(https://movefast.tistory.com/191 참고)  
우선 **pushad**는 쉽게 말하면 스택에 값들을 저장(백업)하는 용도로 사용하는 명령어이다.  그리고 **popad**는 스택에서 저장(백업)했던 값들을 가져오는 명령어이다.  
패킹을 한 파일의 대부분은 pushad를 통해 값을 저장했다가 프로그램을 시작하기 직전에 popad를 통해 값을 가져오고 프로그램을 시작한다.  
따라서 우리는 popad를 찾으면 oep를 찾을 수 있다.  
위에서 참고한 사이트에서 한 것처럼 pushad를 하고나서 스택에 breakpoint를 걸면, 나중에 popad를 실행할 때 멈출 것이다.(값을 가져가기 때문에 breakpoint에 의해 멈춘다)  
그래서 breakpoint를 걸고나서 실행한 결과, 다음 위치로 이동했다.  
<img src="./basic 06/6-6.jpg">  
여기서 우리가 집중해서 봐야하는 명령어는 **jmp**이다.  
왜냐하면 jmp를 통해 이동해야 프로그램을 시작하기 때문이다. 즉, jmp에 있는 주소가 우리가 찾고자 하는 프로그램의 시작 주소이다.  
따라서 oep는 **00401360**이다.  
따라서 정답은 **00401360AD46DFS547** 이다.  

# 7번  
07.exe를 실행하면 다음과 같은 창이 나타납니다.  
<img src="./basic 07/7-1.jpg">  
역시 아무거나 입력하면 다음과 같은 창이 나옵니다.  
<img src="./basic 07/7-2.jpg">  
디버깅을 해보니, 바로 밑에 시리얼처럼 보이는 것들이 보였습니다.
<img src="./basic 07/7-3.jpg">  
그리고 시리얼이 나와있는대로 입력했는데 틀렸다고 나왔습니다. 그래서 시리얼로 추정되는 문자열이 있는 명령어에 breakpoint를 걸고 디버깅을 했습니다.  
<img src="./basic 07/7-4.jpg">  
그런데 갑자기 **로컬 디스크**를 **GetVolumnInformationA** 라는 함수의 결과로 가져왔습니다.  
<img src="./basic 07/7-5.jpg">  
그래서 문제를 보았는데, **컴퓨터 C 드라이브의 이름이 CodeEngn 일경우 시리얼이 생성될때 CodeEngn은 'ß어떤것'으로 변경되는가** 라는 문제였습니다.  
이걸 보고, 저 **로컬 디스크**라는 것이 시리얼에 영향을 준다는 것을 알았습니다. 그래서 로컬 디스크가 있는 메모리 주소로 가서 값을 **CodeEngn**으로 바꾸었습니다.  
<img src="./basic 07/7-6.jpg">  
바꾼 후, 코드를 실행하니까 다음과 같은 시리얼처럼 생긴 문자열이 나왔습니다.  
<img src="./basic 07/7-7.jpg">  
그래서 입력을 했고, 결과는 성공적이었습니다.  
<img src="./basic 07/7-8.jpg">  
그런데 문제는 **CodeEngn은 'ß어떤것'으로 변경되는가**입니다. 그래서 시리얼을 자세히 봤는데, **L2C-5781EqfgEngn4562-ABEX**였습니다. 중간에 Engn이 있는 것으로 보면 CodeEngn이 들어간 것 같은데, CodeEngn이 **EqfgEngn**으로 바뀌어있었습니다.  
따라서 정답은 **EqfgEngn**입니다.  

# 8번  
이 프로그램을 실행하면 다음과 같은 계산기 프로그램이 나옵니다.  
<img src="./basic 08/8-1.jpg">  
우선 이 문제는 **OEP**를 구하는 문제이기 때문에 basic 07과 똑같은 문제입니다.  
근데 저는 basic 07은 직접 breakpoint를 걸어서 풀었는데, 이번에는 **프로그램**을 사용하여 풀어보겠습니다.(https://koharinn.tistory.com/487 https://blueochild.tistory.com/entry/UPX-%EC%96%B8%ED%8C%A8%ED%82%B9-%ED%95%98%EB%8A%94%EB%B2%95 참고)  
먼저 **PEiD**를 사용하여 어떤 방식으로 패킹돼있는지 확인했습니다.  
<img src="./basic 08/8-2.jpg">  
**UPX**로 패킹돼있습니다.  
그래서 UPX를 언패킹했습니다.  
<img src="./basic 08/8-3.jpg">  
그리고 x64dbg를 사용하여 프로그램을 실행하면, 다음과 같이 OEP를 쉽게 구할 수 있습니다.  
<img src="./basic 08/8-4.jpg">  
따라서 OEP는 **01012475** 입니다.  

# 9번  
이 프로그램을 실행하면 다음과 같은 창이 나옵니다.  
<img src="./basic 09/9-1.jpg"> <img src="./basic 09/9-2.jpg">  
이 문제는 **StolenByte**을 구하는 문제입니다.  
StolenByte가 무엇인지 찾아봤습니다.(https://oopsys.tistory.com/179 참고)  
StolenByte는 **패커가 위치를 이동시킨 코드**이고, 쉽게 말하면 훔친 코드입니다. 그래서 **OEP에 들어가기 전에 스택에 PUSH**를 한 것이 StolenByte라고 합니다.  
그래서 basic 07처럼 OEP를 찾았습니다.  
<img src="./basic 09/9-3.jpg">  
lea 명령어 위에 push명령어 3개가 있는 것을 볼 수 있는데, 이것들이 StolenByte 입니다.  
따라서 답은 **6A0068002040006812204000**입니다.  
그런데 다른 사람들의 풀이를 보니까, 언패킹을 했을 때 메세지 창이 오류가 나오는 것을 보고 저도 한번 해봤습니다.  
우선 PEiD를 통해 UPX로 패킹돼있는지 확인합니다.  
<img src="./basic 09/9-4.jpg">  
UPX로 패킹돼있으므로, 언패킹을 합니다.  
<img src="./basic 09/9-5.jpg">  
그리고 실행을 하면 다음과 같이 메세지 창의 글씨가 깨져서 나옵니다.  
<img src="./basic 09/9-6.jpg">  


# 10번  
이 프로그램을 실행하면 다음과 같은 창이 나옵니다.  
<img src="./basic 10/10-1.jpg">  
어떠한 입력도 되지 않습니다. 그래서 일단 이 파일이 패킹이 되었는지 확인을 했습니다.  
<img src="./basic 10/10-2.jpg">  
여기서 지난 문제에서 나왔던 UPX가 아니아 **ASPack**으로 패킹된 것을 확인할 수 있습니다.(https://suspected.tistory.com/93 참고)  
ASPack은 다음과 같은 과정으로 패킹돼있습니다.  
1. PUSHAD 명령어로 현재 레지스터 스택에 저장
2. 원본 코드 특정 메모리 상에 복구
3. POPAD로 레지스터 복구
4. OEP로 분기  
  
UPX와 비슷한 모습을 볼 수 있습니다. 그래서 전에 UPX에서 OEP를 찾았던 것 처럼 popad로 찾아가면 다음과 같은 코드가 존재합니다.  
<img src="./basic 10/10-3.jpg">  
UPX와 약간 다르게 생겼지만, 위에 있는 것 처럼 OEP로 분기하는 부분입니다. 이 코드를 실행하면 아래 2줄의 명령을 실행합니다.  
이 때 **ret**는 return address로 돌아가는데, 이러한 기능이 UPX에서 **JMP**와 동일한 기능입니다. 따라서 위에 push해서 넣은 **00445834**가 OEP가 됩니다.  
다음으로 **'등록성공' 으로 가는 분기점의 OPCODE**를 구해야 하는데, 처음에 사진을 보면 **NOT registered**라는 문구가 있어서, 프로그램이 잘 돌아갔으면 register가 됬다는 문구가 코드에 있어야 한다.  
그래서 전에 했던 것처럼 register 관련 문자열을 찾아봤다.  
<img src="./basic 10/10-4.jpg">  
아래 줄에 **Registered... well done!** 라는 문구가 있다. 딱봐도 우리가 원하는 문구인 것 같다. 그래서 그 문구가 있는 곳을 찾았다.  
<img src="./basic 10/10-5.jpg">  
맨 위에 jne 명령에서 jump를 한다면 성공문구를 지나칠 것이고, jump를 하지 않는다면 한 줄씩 실행해서 성공문구에 도달할 것이다.  
따라서 '등록성공' 으로 가는 분기점의 OPCODE는 **7555**이다.  
이 문제는 **OEP를 구한 후 '등록성공' 으로 가는 분기점의 OPCODE를 구하시오.** 라는 문제이므로, 정답은 **004458347555** 이다.  
